{"ast":null,"code":"import { Reeks } from \"./Entities/Reeks\";\nimport { Categorie } from \"./Enums/Categorie\";\nexport function verdeelInschrijvingenPerCategorie(deelnemers) {\n  let map = new Map();\n  deelnemers.forEach(deelnemer => {\n    var _map$get;\n\n    if (!map.get(deelnemer.categorie)) {\n      map.set(deelnemer.categorie, new Array());\n    }\n\n    (_map$get = map.get(deelnemer.categorie)) === null || _map$get === void 0 ? void 0 : _map$get.push(deelnemer);\n  });\n  return map;\n}\nexport function verdeelReeksenPerCategorie(reeksen) {\n  let map = new Map();\n  reeksen.forEach(reeks => {\n    var _map$get2;\n\n    if (!map.get(reeks.categorie)) {\n      map.set(reeks.categorie, new Array());\n    }\n\n    (_map$get2 = map.get(reeks.categorie)) === null || _map$get2 === void 0 ? void 0 : _map$get2.push(reeks);\n  });\n  return map;\n}\nexport function CreerReeksenUitDeelnemerslijst(deelnemerLijst, aantalBanen) {\n  let ronde = new Array();\n  deelnemerLijst = shuffleDeelnemersLijst(deelnemerLijst);\n  let deelnemersPerCat = verdeelInschrijvingenPerCategorie(deelnemerLijst);\n\n  for (let key of deelnemersPerCat.keys()) {\n    var _deelnemersPerCat$get;\n\n    let newReeks = new Reeks(key, aantalBanen);\n    (_deelnemersPerCat$get = deelnemersPerCat.get(key)) === null || _deelnemersPerCat$get === void 0 ? void 0 : _deelnemersPerCat$get.forEach((deelnemer, index) => {\n      var _deelnemersPerCat$get2;\n\n      let DeelnemerIsLast = index + 1 == ((_deelnemersPerCat$get2 = deelnemersPerCat.get(key)) === null || _deelnemersPerCat$get2 === void 0 ? void 0 : _deelnemersPerCat$get2.length);\n      let ReeksIsFull = newReeks.baanVerdeling.size == aantalBanen - 1;\n      newReeks.addDeelnemer(deelnemer); //Reeks is full\n\n      if (DeelnemerIsLast || newReeks._isFull) {\n        ronde.push(newReeks);\n        newReeks = new Reeks(key, aantalBanen);\n      }\n    });\n  }\n\n  return ronde;\n}\n_c = CreerReeksenUitDeelnemerslijst;\nexport function shuffleDeelnemersLijst(array) {\n  let currentIndex = array.length,\n      randomIndex; // While there remain elements to shuffle...\n\n  while (currentIndex != 0) {\n    // Pick a remaining element...\n    randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex--; // And swap it with the current element.\n\n    [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];\n  }\n\n  return array;\n}\nexport function VoegInschrijvingenToe(inschrijvingsArray, existingInschrijvingsLijst, maxAantalBanen) {\n  let inschrijvingsLijst;\n\n  if (existingInschrijvingsLijst) {\n    inschrijvingsLijst = existingInschrijvingsLijst;\n  } else {\n    inschrijvingsLijst = new Map();\n  }\n\n  let inteschrijvenDeelnemersPerCategorie = verdeelInschrijvingenPerCategorie(inschrijvingsArray); //loop over elke categorie\n\n  for (let categorie in Categorie) {\n    //ga alleen verder met categorien waarvan moet worden ingeschreven\n    if (inteschrijvenDeelnemersPerCategorie.has(categorie)) {\n      //Als Categorie nog niet bestaan in inschrijvingslijst\n      if (!inschrijvingsLijst.has(categorie)) {\n        //voeg categorie toe aan inschrijvingslijst\n        inschrijvingsLijst.set(categorie, new Array(new Reeks(categorie, maxAantalBanen)));\n      } //sorteer deelnemers per Categorie\n\n\n      inteschrijvenDeelnemersPerCategorie.get(categorie) //Voor elke deelnemer in huidige categorie\n      .forEach(deelnemer => {\n        let inschrijvingsLijstVanCategorie = inschrijvingsLijst.get(categorie); //filter\n\n        let OpenRaces = inschrijvingsLijstVanCategorie.filter(reeks => !reeks._isFull);\n\n        if (OpenRaces.length > 0) {\n          OpenRaces[0].addDeelnemer(deelnemer);\n        } else {\n          let newReeks = new Reeks(categorie, maxAantalBanen);\n          newReeks.addDeelnemer(deelnemer);\n          inschrijvingsLijst.get(categorie).push(newReeks);\n        }\n      });\n    }\n  }\n\n  return inschrijvingsLijst;\n}\n_c2 = VoegInschrijvingenToe;\nexport function replacer(key, value) {\n  if (value instanceof Map) {\n    return {\n      dataType: \"Map\",\n      value: Array.from(value.entries()) // or with spread: value: [...value]\n\n    };\n  } else {\n    return value;\n  }\n}\nexport function reviver(key, value) {\n  if (typeof value === \"object\" && value !== null) {\n    if (value.dataType === \"Map\") {\n      return new Map(value.value);\n    }\n  }\n\n  return value;\n}\n\nvar _c, _c2;\n\n$RefreshReg$(_c, \"CreerReeksenUitDeelnemerslijst\");\n$RefreshReg$(_c2, \"VoegInschrijvingenToe\");","map":{"version":3,"sources":["/Users/bramsikkens/Documents/Ontwikkeling/Propaganda/PropagandaSysteem/src/DomainLayer/utils.ts"],"names":["Reeks","Categorie","verdeelInschrijvingenPerCategorie","deelnemers","map","Map","forEach","deelnemer","get","categorie","set","Array","push","verdeelReeksenPerCategorie","reeksen","reeks","CreerReeksenUitDeelnemerslijst","deelnemerLijst","aantalBanen","ronde","shuffleDeelnemersLijst","deelnemersPerCat","key","keys","newReeks","index","DeelnemerIsLast","length","ReeksIsFull","baanVerdeling","size","addDeelnemer","_isFull","array","currentIndex","randomIndex","Math","floor","random","VoegInschrijvingenToe","inschrijvingsArray","existingInschrijvingsLijst","maxAantalBanen","inschrijvingsLijst","inteschrijvenDeelnemersPerCategorie","has","inschrijvingsLijstVanCategorie","OpenRaces","filter","replacer","value","dataType","from","entries","reviver"],"mappings":"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","sourcesContent":["import RaceEntry from \"./Abstracts/RaceEntry\";\nimport { Deelnemer } from \"./Entities/Deelnemer\";\nimport { Reeks } from \"./Entities/Reeks\";\nimport { Categorie } from \"./Enums/Categorie\";\n\nexport function verdeelInschrijvingenPerCategorie(\n  deelnemers: Array<RaceEntry>\n): Map<Categorie, Array<RaceEntry>> {\n  let map: Map<Categorie, Array<RaceEntry>> = new Map();\n  deelnemers.forEach((deelnemer: RaceEntry) => {\n    if (!map.get(deelnemer.categorie)) {\n      map.set(deelnemer.categorie, new Array<RaceEntry>());\n    }\n    map.get(deelnemer.categorie)?.push(deelnemer);\n  });\n  return map;\n}\n\nexport function verdeelReeksenPerCategorie(\n  reeksen: Array<Reeks>\n): Map<Categorie, Array<Reeks>> {\n  let map: Map<Categorie, Array<Reeks>> = new Map();\n  reeksen.forEach((reeks: Reeks) => {\n    if (!map.get(reeks.categorie)) {\n      map.set(reeks.categorie, new Array<Reeks>());\n    }\n    map.get(reeks.categorie)?.push(reeks);\n  });\n\n  return map;\n}\n\nexport function CreerReeksenUitDeelnemerslijst(\n  deelnemerLijst: Array<RaceEntry>,\n  aantalBanen: number\n) {\n  let ronde = new Array<Reeks>();\n\n  deelnemerLijst = shuffleDeelnemersLijst(deelnemerLijst);\n\n  let deelnemersPerCat: Map<\n    Categorie,\n    Array<RaceEntry>\n  > = verdeelInschrijvingenPerCategorie(deelnemerLijst);\n\n  for (let key of deelnemersPerCat.keys()) {\n    let newReeks = new Reeks(key, aantalBanen);\n    deelnemersPerCat.get(key)?.forEach((deelnemer: RaceEntry, index) => {\n      let DeelnemerIsLast = index + 1 == deelnemersPerCat.get(key)?.length;\n      let ReeksIsFull = newReeks.baanVerdeling.size == aantalBanen - 1;\n      newReeks.addDeelnemer(deelnemer);\n      //Reeks is full\n      if (DeelnemerIsLast || newReeks._isFull) {\n        ronde.push(newReeks);\n        newReeks = new Reeks(key, aantalBanen);\n      }\n    });\n  }\n  return ronde;\n}\n\nexport function shuffleDeelnemersLijst(array: Array<RaceEntry>) {\n  let currentIndex = array.length,\n    randomIndex;\n\n  // While there remain elements to shuffle...\n  while (currentIndex != 0) {\n    // Pick a remaining element...\n    randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex--;\n\n    // And swap it with the current element.\n    [array[currentIndex], array[randomIndex]] = [\n      array[randomIndex],\n      array[currentIndex],\n    ];\n  }\n\n  return array;\n}\n\nexport function VoegInschrijvingenToe(\n  inschrijvingsArray: Array<RaceEntry>,\n  existingInschrijvingsLijst?: Map<Categorie, Array<Reeks>>,\n  maxAantalBanen?: number\n): Map<Categorie, Array<Reeks>> {\n  let inschrijvingsLijst: Map<Categorie, Array<Reeks>>;\n\n  if (existingInschrijvingsLijst) {\n    inschrijvingsLijst = existingInschrijvingsLijst;\n  } else {\n    inschrijvingsLijst = new Map<Categorie, Array<Reeks>>();\n  }\n\n  let inteschrijvenDeelnemersPerCategorie =\n    verdeelInschrijvingenPerCategorie(inschrijvingsArray);\n\n  //loop over elke categorie\n  for (let categorie in Categorie) {\n    //ga alleen verder met categorien waarvan moet worden ingeschreven\n    if (inteschrijvenDeelnemersPerCategorie.has(categorie as Categorie)) {\n      //Als Categorie nog niet bestaan in inschrijvingslijst\n      if (!inschrijvingsLijst.has(categorie as Categorie)) {\n        //voeg categorie toe aan inschrijvingslijst\n        inschrijvingsLijst.set(\n          categorie as Categorie,\n          new Array<Reeks>(new Reeks(categorie as Categorie, maxAantalBanen))\n        );\n      }\n\n      //sorteer deelnemers per Categorie\n      inteschrijvenDeelnemersPerCategorie\n        .get(categorie as Categorie)!\n        //Voor elke deelnemer in huidige categorie\n        .forEach((deelnemer: RaceEntry) => {\n          let inschrijvingsLijstVanCategorie: Array<Reeks> =\n            inschrijvingsLijst.get(categorie as Categorie)!;\n\n          //filter\n          let OpenRaces = inschrijvingsLijstVanCategorie.filter(\n            (reeks: Reeks) => !reeks._isFull\n          );\n\n          if (OpenRaces.length > 0) {\n            OpenRaces[0].addDeelnemer(deelnemer);\n          } else {\n            let newReeks: Reeks = new Reeks(\n              categorie as Categorie,\n              maxAantalBanen\n            );\n            newReeks.addDeelnemer(deelnemer);\n            inschrijvingsLijst.get(categorie as Categorie)!.push(newReeks);\n          }\n        });\n    }\n  }\n\n  return inschrijvingsLijst;\n}\n\nexport function replacer(key: any, value: any) {\n  if (value instanceof Map) {\n    return {\n      dataType: \"Map\",\n      value: Array.from(value.entries()), // or with spread: value: [...value]\n    };\n  } else {\n    return value;\n  }\n}\n\nexport function reviver(key: any, value: any) {\n  if (typeof value === \"object\" && value !== null) {\n    if (value.dataType === \"Map\") {\n      return new Map(value.value);\n    }\n  }\n  return value;\n}\n\nexport function howManyTeamMembers(boottype:B)"]},"metadata":{},"sourceType":"module"}